Выведите все элементы списка с четными индексами (то есть A[0], A[2], A[4], ...). 

a=input().split()
for i in range (0, len(a) ,2):
	print (a[i],  end=' ' )


Выведите все четные элементы списка. При этом используйте цикл for, перебирающий элементы списка, а не их индексы! 
a = input ().split ()
s=[]
for i in a:
	i = int (i)
	if i % 2 == 0:
		print (i, end=' ')


Дан список чисел. Выведите все элементы списка, которые больше предыдущего элемента. 

a= [int(numbers) for numbers in input().split()]
for i in range (1 , len (a)):
    if a[i] > a[i-1]:
        print (a[i], end=' ')


Дан список чисел. Если в нем есть два соседних элемента одного знака, выведите эти числа. Если соседних элементов одного знака нет — не выводите ничего. Если таких пар соседей несколько — выведите первую пару. 

List = [int(a) for a in input().split()]
for i in range (1, len(List)):
    if List[i - 1] < 0 and List[i] <0 or List [i-1]> 0 and List[i]>0:
    # if List [i-1] * List [i] > 0
        print (List[i-1], List [i])
        break


Дан список чисел. Определите, сколько в этом списке элементов, которые больше двух своих соседей, и выведите количество таких элементов. Крайние элементы списка никогда не учитываются, поскольку у них недостаточно соседей. 

List = [int(i) for i in input().split()]
NumOfMax=0
for i in range (1, len(List)-1):
    if List[i] > List[i-1] and List[i] > List[i+1]:
        NumOfMax+=1
print (NumOfMax)


Дан список чисел. Выведите значение наибольшего элемента в списке, а затем индекс этого элемента в списке. Если наибольших элементов несколько, выведите индекс первого из них. 

numbers = [int(i) for i in input().split()]
print (max(numbers), numbers.index(max(numbers)))


Петя перешёл в другую школу. На уроке физкультуры ему понадобилось определить своё место в строю. Помогите ему это сделать.

Программа получает на вход невозрастающую последовательность натуральных чисел, означающих рост каждого человека в строю. После этого вводится число X – рост Пети. Все числа во входных данных натуральные и не превышают 200.

Выведите номер, под которым Петя должен встать в строй. Если в строю есть люди с одинаковым ростом, таким же, как у Пети, то он должен встать после них.

list_height = [int(i) for i in input().split()]
new_sportsmen=int(input())
for i in range (len(list_height)):
    if new_sportsmen > list_height[i]:
        print (i+1)
        break
if min(list_height) >= new_sportsmen:
    print (i+2)


Дан список, упорядоченный по неубыванию элементов в нем. Определите, сколько в нем различных элементов. 

List = [int(i) for i in input().split()]
quantity=1
for i in range (1, len(List)):
    if List[i-1] != List[i]:
        quantity += 1
print (quantity)


Переставьте соседние элементы списка (A[0] c A[1], A[2] c A[3] и т. д.). Если элементов нечетное число, то последний элемент остается на своем месте.

a = [int(i) for i in input().split()]
i=1
while i < len(a):
   a[i], a[i-1] = a[i-1], a[i]
   i+=2
print (' '.join([str(i) for i in a]))


В списке все элементы различны. Поменяйте местами минимальный и максимальный элемент этого списка. 

List = [int(i) for i in input().split()]
a = List.index(min(List))
b = List.index(max(List)) 
List[a], List[b] = List[b], List[a]
print (' '.join([str(i) for i in List]))


Дан список из чисел и индекс элемента в списке k. Удалите из списка элемент с индексом k, сдвинув влево все элементы, стоящие правее элемента с индексом k.

Программа получает на вход список, затем число k. Программа сдвигает все элементы, а после этого удаляет последний элемент списка при помощи метода pop() без параметров.

Программа должна осуществлять сдвиг непосредственно в списке, а не делать это при выводе элементов. Также нельзя использовать дополнительный список. Также не следует использовать метод pop(k) с параметром. 

a = [int(i) for i in input().split()]
k=int(input())
for i in range (k, len(a) - 1):
    a[i] = a [i + 1]
a.pop()
print (' '.join([str(i) for i in a]))


Дан список целых чисел, число k и значение C. Необходимо вставить в список на позицию с индексом k элемент, равный C, сдвинув все элементы, имевшие индекс не менее k, вправо.

Поскольку при этом количество элементов в списке увеличивается, после считывания списка в его конец нужно будет добавить новый элемент, используя метод append.

Вставку необходимо осуществлять уже в считанном списке, не делая этого при выводе и не создавая дополнительного списка. 

numbers = [int(i) for i in input().split()]
k, c = [int(i) for i in input().split()]
numbers.append(c)
for i in range (len(numbers)-1, k, -1):
    numbers[i], numbers[i-1] = numbers [i-1], numbers [i]
print (' '.join([str(i) for i in numbers]))

Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу. Считается, что любые два элемента, равные друг другу образуют одну пару, которую необходимо посчитать. 

a = [int(i) for i in input().split()]
duplex = 0
for i in range (0, len(a)-1):
    b=a[i+1:]
    duplex+=b.count(a[i])
print (duplex)

Дан список. Выведите те его элементы, которые встречаются в списке только один раз. Элементы нужно выводить в том порядке, в котором они встречаются в списке. 

a = [int(i) for i in input().split()]
for i in (a):
    if a.count(i) == 1:
        print (i, end=' ')


Условие
N кеглей выставили в один ряд, занумеровав их слева направо числами от 1 до N. Затем по этому ряду бросили K шаров, при этом i-й шар сбил все кегли с номерами от li до ri включительно. Определите, какие кегли остались стоять на месте.

Программа получает на вход количество кеглей N и количество бросков K. Далее идет K пар чисел li, ri, при этом 1≤ li≤ ri≤ N.

Программа должна вывести последовательность из N символов, где j-й символ есть “I”, если j-я кегля осталась стоять, или “.”, если j-я кегля была сбита. 

n, k = [int(i) for i in input().split()]
towers = ['I']*n
for i in range (k):
    drops = [int(l) for l in input().split()]
    towers[drops[0]-1:drops[1]] = ['.']* (drops[1]-drops[0]+1)
print (''.join(towers))


Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били друг друга. Вам дана расстановка 8 ферзей на доске, определите, есть ли среди них пара бьющих друг друга.

Программа получает на вход восемь пар чисел, каждое число от 1 до 8 — координаты 8 ферзей. Если ферзи не бьют друг друга, выведите слово NO, иначе выведите YES. 

queen = []
gor = []
vert = []
answer = 'NO'
for i in range (8):
    queen = ([int(j) for j in input().split()])
    gor += [queen[0]]
    vert += [queen[1]]
for i in range (8):
    for j in range (i+1, 8):
        if gor[i] == gor[j] or vert[i] == vert[j]:
            answer = 'YES'
            break
        if abs(gor[i] - gor[j]) == abs(vert[i] - vert[j]):
            answer = 'YES'
            
print (answer)




